HTTP协议
	请求消息，客户端：客户端发送个服务端的数据
			数据格式
				请求行
				请求头
				请求空行
				请求体
		响应数据：服务器端发送给客户端的数据
			数据格式
				响应行
					组成:协议/版本  响应状态码  状态码描述
					响应状态码：服务器告诉客户端浏览器本次请求和响应的状态
					状态码都是3位数
						分类
							100多：服务器接收客户端消息，但是没有接收完成，等待一段时间后，发送100多状态码
							200多：成功，代表：200
							300多：重定向 。代表：302（重定向），304（访问缓冲）
							400多：失败：客户端错误。代表404（请求路径没有对应的资源） 405（请求方式和对应的doxxx方法）
							500多：失败：服务器错误。代表500（服务器内部错误）
						
				响应头：
					格式：头的名称：值
					常见的响应头：
						Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
						content-disposition：服务器告诉客户端以什么格式打开响应体数据
							默认值 in_line 在当前页面内部打开
							attachment；filename=xxx 以附件形式打开响应体，文件下载
				响应空行
				响应体：传输的数据
			
		响应的数据格式：
			HTTP/2.0 200 OK  : 响应行 HTTP协议/版本信息  状态码 状态码的表述
			下面	
			
###Response对象
	功能：设置响应消息
		设置响应行
			格式：HTTP/1.1 OK
			设置状态码setStatus（int sc）
		设置响应头	setHeader（String name，String value）
		设置响应体	
			使用步骤	
				获取输出流
					字符流：PrintWriter getWrite（）
					字节流：ServletOutputStream getOutputStream（）
				使用输出流，将数据输出到客户端浏览器

		完成重定向
			资源跳转的一种方式
				代码：
					response.setStatus(302);    response.setHeader("localhost","/serlvetdome2");
					response.senndRedirect("/servlet");(我们一般使用这个方法 进行重定向)
				重定向的特点：redirect
					地址栏发生变化
					重定向可以访问其他站点（服务器）的资源
					重定向是两次请求
					可以访问其他网页的资源  只要写上地址
					不可以使用request对象来共享数据
				转发的特点：forward
					转发地址栏不变
					转发只能访问当前服务器下的资源
					转发是一次请求
					只能访问当前服务器下的资源
					可以使用request对象来共享数据
					
				路径写法:
					路径的分类
						相对路径:通过相对路径不可以确定唯一资源 
							如:./index.html
							已以./开头或../开头的为相对路径  点杠可以不写 默认是点杠 
 
							规则：找到当前资源和目标资源之间的相对关系
							./当前目录  ../后退一级目录							
	
						绝对路径：通过绝对路径可以确定唯一资源
							如：http://localhost/resdfome   现在可以写成  /resdfome
							以/开头的路径

						规则：判断定义的路径是给谁用的？请求请求是从哪里发出的
							给客户端使用：需要加虚拟目录（项目的访问路径）
								建议虚拟目录 动态获取:request.getContextPath()
							给服务器内部使用;不需要加虚拟目录
						request.getContextPath(); 返回一个当前目录下的当前虚拟目录 
							转发路径
		

		服务器输出字符数据到浏览器
			获取流对象之前，设置默认编码：
			response.setCharacterEncoding("utf-8");
			告诉浏览器，服务器发送的消息体数据的编码，建议浏览器使用该编码（只需写这个就行了）
			response.setHeader("content-type","text/html;charset=utf-8");
			简单形式，设置编码response.set	
			response.setContentType("text/html;charset=utf-8");

			步骤：
				获取转发输出流
				输出数据
			注意乱码问题：
				PrintWrite pw=response.getWriter();获取的流是默认编码是ISO-8859-1
				设置该流的默认编码
				告诉浏览器响应体使用编码
					简单形式，设置编码
						response.setContentType("text/html;charset=utf-8");
			
					
	
		服务器输出字节数据到浏览器
			步骤：
				获取字节输出流		ServletOutputStream SOS=response.getOutputStream();
				输出数据		
			乱码问题  response.serContentType("text/html;charset=utf-8");

		验证码
			本质：图片
			目的：可以防止恶意注册
			验证码可以使用图片（但是图片有限 不推荐）
				也可以使用java程序自己画（可以使用随机数，这样就有无限可能）
		代码;
			创建一个，在内存中画图（代表这个图片）的对象
					BufferdImage imahe=new Bufferedimage(width,heigth,BufferedImage.TYPE_INT_RGB);				

			美化图片
				Graphiocs g=image.getGrapghics();画笔对象
				g.setcolor(Color.pink);设置画笔颜色
				g.fillRect(0,0,width,height);//在哪里显示
					画边框
						g.setcolor(Color.BLUE);//设置颜色
						g.drawRect(0,0,width-1,height-1);边框

						写验证码 写字符串 可以使用随机数 
							gdrawString("a",20,30);	
						写线条;(可以使用for循环 画多条线条)
							g.drwLine(1,1,30,30);


			将图片输出到页面展示
				ImageIO.write(image,"jpg",response.getOutputStream());
		<img src="/checke">(可以绑定单击事件 每点击异常调用此servlet 随机生成图片 ) 但是浏览器会默认缓存 所以每次的名字都要不一样 可以加个？getTime
				


		ServletContext对象(生命周期很长  在servlet创建 他就存在，到servlet消亡了 才消失 ，而且每个用户都可以使用它  我们需要谨慎使用)
			概念：代表整个web应用，可以和程序的容器（服务器）通信
			获取：	
				通过request对象获取
					request.getServletContext();	
					this.getServletContext();
			功能：
				获取MIME类型：
					MIME类型：在互联网通信过程中的一种文件数据类型
						格式：大类型/小类型  如text/HTML   image/jpeg  在Context-type响应头中 就需要设置 你设置那种类型他就会使用那种类型解析			
					获取;
						getMimeType(String name); 如：a.JPG  他就会返回 image/jpeg 他就会以这个类型解析 否则他就会以text/html 解析

	
				域对象：共享数据
					context.setAttribute(String name, Object value); 取个名字 设置值
					context.setAttribute(String name)：根据名称获取 值
					context.removeAttribute(String name);根据名称删除 值


				获取文件的真实路径（服务器）：
					方法
						context.getRealPath(String path); 在本文件路径下 就是用/a.txt  在 WEB-INF下就要写 /WEB-INF/a.txt 在src下就要写
							/WEV-INF/classes/a.txt

				代码
			<a href="/deom?filename=图片名称+后缀名">  可以使用 request.getparameter获取 图片名称和后缀名  在使用response的字节了流输出到页面 需要设置 content-disponsition:attachment;filename=xxx//设置打开方式
 response.setHeader("content-type",mimeType);//设置响应方式



